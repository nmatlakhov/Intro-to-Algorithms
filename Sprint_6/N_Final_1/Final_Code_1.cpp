/*
https://contest.yandex.ru/contest/25070/run-report/82462205/
ПРИНЦИП РАБОТЫ:
Поскольку мы не ожидаем плотного графа, то будем хранить ребра в виде списков смежности. За основу берется алгоритм Прима, описанный в разделе Минимальное остовное дерево, но с рядом модификаций.
Комментарии даны ниже в коде.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
1) Если у графа есть кратные ребра, то берём то у которого больший вес. Петли - игнорируем.
2) При инициализации создается хэш-таблица вершин, еще не добавленных в остов.
3) В случае кратных ребёр будем записывать в граф ребра с максимальным весом.
4) Чтобы дерево получилось максимальным мы будем извлекать ребра из графа с наибольшим весом, используя приоритетную очередь.

Если граф несвязнный, то остовное дерево составить не получится (потому что будет несколько компонент связности).
Если граф связный, то будет осуществлен обход по всем вершинам и их ребрам, причем ребра будут выбираться с наибольшим весом => дерево будет иметь максимальный вес.

Пусть у нас V вершин и E рёбер в графе.
ВРЕМЕННАЯ СЛОЖНОСТЬ:
1) Создание хэш-таблицы ~O(V)
2) Добавление рёбер ~O(E)
3) Вставка и удаление рёбер в приоритетную очередь ~O(log V) в худшем случае, если вершина, ребра которое мы добавляем, соединена со всеми остальными вершинами
4) Доступ к элементам в хэш-таблице в худшем случае ~O(V) в среднем ~O(1)
5) Доступ к элементам в массиве вершин ~O(1)
6) В худшем случае, прежде чем закончатся не добавленные вершины, в очереди будут все ребра => добавление E вершин в приоритетную очередь ~O(E log V)
Итого: ~O(E log V)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
1) Граф мы храним в виде списков смежности => его пространственная сложность ~O(V + E)
2) Массив вершин ~O(V)
3) Приоритетная очередь из рёбер ~O(E)
Итого: ~O(V + E)

*/

#include<iostream>
#include<unordered_map>
#include<queue>
using namespace std;

// Класс используемого графа
class Graph {
public:
	Graph(int V) {
		vertices_num = V;
		add_count = V;
		// Зарезервируем объем хэш-таблиц под задаваемое число вершин
		graph.rehash(V);
		added.resize(V, false);

	};

	// Добавление ребра в граф
	void add_weighted_edge(int start, int end, int weight) {
		// Игнорируем петли + если добавляем уже существующее ребро с большим весом, то обновляем у ребра вес
		if ((start != end) && (graph[start][end] == 0) || (graph[start][end] < weight)) {
			graph[start][end] = weight;
			graph[end][start] = weight;
		}
	}


	// Добавление ребер исходящих из вершины v в остов
	void add_vertex(int v) {

		// Указываем вершину как добавленную
		added[v-1] = true;

		// Уменьшаем счетчик вершин на 1
		add_count--;

		// Проходимся по всем ребрам, исходящим из добавляемой вершины и рассматриваем вершину на другом конце ребра
		for (auto it = graph[v].begin(); it != graph[v].end(); it++) {

			// Если принимающая вершина ещё не добавлена, то добавляем связывающее ребро в остовное дерево (приоритетную очередь)
			if (!added[it->first - 1] ) {
				edges.push({ it->second,{v,it->first} });
			}
		}
	}


	// Поиск максимального остовного дерева
	int find_MaxST_weight() {

		// Зададим нулевой изначальный вес
		int weight = 0;

		// Если граф состоит из одной вершины, то вернём нулевой вес
		if (vertices_num == 1) {
			return weight;
		}

		// Если граф пустой, то вернём вес равный -1, чтобы указать на отсутствие любого дерева
		if (graph.begin() == graph.end()) {
			return -1;
		}

		// Возьмем любую вершину графа (в данном случае первую в хэш-таблице), в алгоритме Прима не важно с какой вершины начинать,
		// поскольку все вершины попадут в остовное дерево
		int v = graph.begin()->first;

		// Добавим выбранную вершину в остов
		add_vertex(v);

		// Будем продолжать процедуру пока не закончатся вершины или рёбра
		while ((add_count > 0 ) & (!edges.empty())) {

			// Извлекаем ребро из приоритетной очереди с наибольшим весом
			pair<int, pair<int, int>> ex = edges.top();

			// Извлекаем вершины ребра, его исходящая вершина уже добавлена в остов, тогда как принимающая пока ещё нет
			pair<int, int> e = ex.second;

			// Удаляем ребро из очереди
			edges.pop();

			// Если принимающая вершина ещё не была добавлена, то
			if (!added[e.second - 1]) {

				// Увеличиваем вес графа на вес рассматриваемого ребра
				weight += graph[e.first][e.second];

				// Добавляем все исходящие ребра из принимающей вершины
				add_vertex(e.second);
			}

		}

		// Если у нас остались не выбранные вершины, то граф несвязный => нельзя построить остовное дерево, возвращаем -1
		// В противном случае, возвращаем максимальный вес полученного дерева
		if (add_count > 0) {
			return -1;
		}
		else {
			return weight;
		}
	}

private:
	int vertices_num; // Число вершин в графе
	int add_count;

	unordered_map<int, unordered_map<int, int>> graph; // Граф в виде списков смежности
	vector<bool> added; // Массив добавленных вершин 

	// Массив ребер исходящих из остовного дерева представим в виде очереди с приоритетом, где первым аргументом является вес ребра, вторым - начало и конец ребра
	priority_queue<pair<int, pair<int, int>>> edges;

};

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int V, E;
	cin >> V >> E;
	Graph graph(V);

	int start_vert, end_vert, weight;
	for (int i = 0; i < E; i++) {
		cin >> start_vert >> end_vert >> weight;
		graph.add_weighted_edge(start_vert, end_vert, weight);
	}


	int max_weight = graph.find_MaxST_weight();

	if (max_weight == -1) {
		cout << "Oops! I did it again" << endl;
	}
	else {
		cout << max_weight << endl;
	}

	return 0;
}