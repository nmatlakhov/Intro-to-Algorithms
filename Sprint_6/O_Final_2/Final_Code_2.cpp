/*
https://contest.yandex.ru/contest/25070/run-report/82224366/
ПРИНЦИП РАБОТЫ:
Граф плотный => используем матрицу смежности. При использовании списков смежности за счет плотности графа будем выходить за лимиты по памяти (например, STL list будет требовать на запись ~24 байта, 
вместо 4 байт для вектора, поскольку на каждой записи будет содержаться ссылки на предыдущий и последующий элементы).
Для проверки циклов используется обход в глубину с использованием цветов. Воспользуемся описанием из учебных материалов.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
Чтобы маршрут был оптимальным для каждой пары городов должен существовать единственный тип дороги. Т.е. невозможно добраться из A в B несколькими путями =>
=> если развернуть один из путей, то мы получим цикл => необходимо проверить, есть ли циклы в графе.

Нам необходимо пройтись по всем вершинам графа с DFS, поскольку возможны примеры графов, где DFS из первой вершины будет давать положительный ответ, хотя вообще говоря 
циклы есть. Например:
6
BBBBB
RBRR
BRR
BB
B

ИЛИ

5
BBBB
RBR
BR
B

Пусть у нас V вершин и E рёбер в графе.
ВРЕМЕННАЯ СЛОЖНОСТЬ:
1) Создание и наполнение матрицы смежности ~O(V^2)
2) Создание и очистка массива цветов ~O(V)
3) Проход по каждой вершине ~O(V), поскольку обойдем всего V вершин. Для каждой из вершин проход будет осуществляться примерно за ~O(V) => проход по каждой из вершин по всему графу ~O(V^2).
Итого: ~O(V^2)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
1) Создание и наполнение матрицы смежности ~O(V^2)
2) Создание и очистка массива цветов ~O(V)
Итого: ~O(V^2)

*/


#include<iostream>
#include<vector>
#include<list>
#include<stack>
using namespace std;

enum class Colour {
	white,
	grey,
	black
};

class Graph {
public:
	Graph(int V) {
		num_of_vertices = V;
		graph.resize(V + 1);
		graph_colour.resize(V, Colour::white);
	};

	void add_edge(int start, int end) {
		// Добавление ребра, поскольку граф направленный, то только в одну сторону
		graph[start].push_back(end);
	}

	void clear_graph() {
		// Очистка цветов в графе перед очередным проходом в глубину
		graph_colour.resize(graph_colour.size(), Colour::white);
	}

	// Обход в глубину DFS для поиска цикла
	bool dfs_acycle_search_node(int start_node) {
		
		// Создаем стэк для исходящих вершин
		stack<int> Stack;

		// Кладем в него входящую вершину
		Stack.push(start_node);

		// Совершаем цикл до тех пор, пока не останется исходящих вершин => стэк будет пуст
		while (!Stack.empty()) {

			// Забираем вершину из стэка и удаляем её из него
			int v = Stack.top();
			Stack.pop();

			// Если цвет вершины - белый => не посетили => красим цвет в серый и добавляем вершину обратно в стэк, чтобы вернуться сюда после обхода всех белых вершин
			if (graph_colour[v - 1] == Colour::white) {
				graph_colour[v - 1] = Colour::grey;
				Stack.push(v);

				// Рассмотрим все ребра, выходящие из нашей вершины и рассмотрим их конечные вершины (выходящие)
				for (auto it = graph[v].begin(); it != graph[v].end(); it++) {
					int w = *it;

					// Если цвет вершины белы -> добавляем её в стэк, чтобы покрасить в серый и рассмотреть её вершины далее
					if (graph_colour[w - 1] == Colour::white) { Stack.push(w); }
					else if (graph_colour[w - 1] == Colour::grey) { 
						// Если во время обхода принимающая вершина серого цвета => мы наткнулись на цикл в рамках обхода в глубину, чтобы не было цикла либо 
						// выходящие ребра должны отсутствовать, либо цвет конечных вершин должен быть белым или черным, но не сервым
						return false; 
					}
				}

			}
			// Если цвет вершиный серы => уже посещали её и обход в глубину по этому направлению закончился => красим её в черный цвет
			else if (graph_colour[v - 1] == Colour::grey) {
				graph_colour[v - 1] = Colour::black;

			}
		}

		return true;
	}


	bool dfs_acycle_search() {
		
		// Пройдемся по каждой вершине графа, чтобы исключить цикл с возвращением к предыдущим вершинам
		for (int i = 0; i < num_of_vertices; i++) {
			
			// Поскольку каждый раз мы закрашиваем вершины, то перед очередным расчётом необходимо очистить цвета
			clear_graph();

			// Если хотя бы из одной вершины найдется цикл, то карта не будет являться оптимальной
			if (!dfs_acycle_search_node(i + 1)) {
				return false;
			}
		}

		// Если из любой вершины графа циклы не нашлись, то карта является оптимальной
		return true;
	}

private:
	vector<vector<int>> graph; // Матрица смежности используется из-за высокой плотности графа (используем половину матрицы)
	vector<Colour> graph_colour; // Окраска цветов соответствует алгоритму DFS
	int num_of_vertices; // Число вершин вынесено в отдельную переменную ради удобства
};

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int V, E;
	cin >> V;
	E = V * (V - 1) / 2;
	Graph graph(V);

	char road;
	for (int i = 0; i < V - 1; i++) {
		for (int j = i + 1; j < V; j++) {
			cin >> road;
			if (road == 'R') { graph.add_edge(i + 1, j + 1); }
			else if (road == 'B') { graph.add_edge(j + 1, i + 1); }
		}
	}

	if (graph.dfs_acycle_search()) {
		cout << "YES" << endl;
	}
	else {
		cout << "NO" << endl;
	}

	return 0;
}