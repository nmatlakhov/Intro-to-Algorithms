/*
https://contest.yandex.ru/contest/22781/run-report/76632051/

-- ПРИНЦИП РАБОТЫ --
1) На основе стандартного контейнера vector создается класс Deque, в котором мы создаем вектор фиксированной длины (чтобы получить кольцевой буфер) m; 
2) Длина вектора подается при инициализации класса дэка;
3) Чтобы иметь кольцевой буфер по заполнению также инициализируем размер дэка и добавляем новые элементы в вектор, пока размер дэка не достигнет максимального размера;
4) Для методов дэка push_front и push_back используем индексы head и tail при добавлении элементов, поскольку вектор фиксированной длины и можно размещать элементы по этим индексам;
5) По достижению максимального размера дэка при попытке добавить элемент, то выдается исключение исполнения с текстом ошибки error, ловим его в main и выводим при получении;
6) При удалении элементов из дэка (размер дэка > 0), выводится удаляемый элемент и размер дэка уменьшается и мы вновь можем разместить новый элемент на освободившееся место;
7) Если размер дэка был 0, то при удалении элементов выдается исключение исполнения с текстом ошибки error, ловим его в main и выводим при получении;

Определим head - индекс текущей вершины дэка, tail - индекс текущего конца дэка, тогда методы будут совершать следующие операции:
a) push_front: при добавлении элемента в вершину дэка, мы должны сместить head на один элемент влево (против часовой стрелки): head => (head -1 + max_size) % max_size;
b) pop_front: при удалении элемента из вершины дэка, мы должны сместить head на один элемент вправо (по часовой стрелке): head => (head + 1) % max_size;
c) push_back: при добавлении элемента в конец дэка, мы должны сместить tail на один элемент вправо (по часовой стрелке): tail => (tail + 1) % max_size; 
d) pop_back: при удалении элемента из конца дэка, мы должны сместить tail на один элемент влево (против часовой стрелки): tail => (tail - 1 + max_size) % max_size;

При сдвигах индексов влево max_size добавляется, чтобы получать всегда неотрицательные значения индекса.

Методы push_front и push_back невозвратные, тогда как pop_front и pop_back возвращают элементы из начала и конца дэка соответственно, при этом сдвигаясь по кольцевому буферу, то есть
по сути эти элементы больше не будут содержаться в дэке. 

В случае, если дэк пустой или заполненный, то будет выдаваться исключение исполнения в методах pop_front, pop_back и push_front, push_back соответственно.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
При нулевом размере дэка удаление элементов будет выдавать сообщение об ошибке.
При размере дэка равному максимальному добавление элементов будет выдавать сообщение об ошибке.

Добавление элементов в вершину дэка будет сдвигать индекс вершины влево, удаление элементов с вершины дэка будет сдвигать индекс вершины вправо на последовательности: 0, 1, 2, ..., m-1, 
где m - максимальный размер дэка. Поскольку новый индекс получается как остаток от деления на макс.размер m, то получаемое значение будет в диапазоне: (0, ..., m-1) => по этому индексу можно
изменять элемент в векторе размера m, на основе которого построен дэк. 

Аналогично, добавление элементов в конец дэка будет сдвигать индекс вершины вправо, удаление элементов с конца дэка будет сдвигать индекс вершины влево на последовательности: 0, 1, 2, ..., m-1, 
где m - максимальный размер дэка. Поскольку новый индекс получается как остаток от деления на макс.размер m, то получаемое значение будет в диапазоне: (0, ..., m-1) => по этому индексу можно
изменять элемент в векторе размера m, на основе которого построен дэк. 

При удалении всех элементов/инициализации дэка, индексы окажутся в одном месте. Но при первом добавлении элемента индексы будут на разных местах (и так до полного заполнения дэка).
Поскольку индексы вершины сдвигаются влево, а индексы хвоста вправо при добавлении элементов и при их встрече дэка будет заполнена (выведется сообщение об ошибке), то они не будут пересекаться.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
1) Инициализация вектора длины m: O(m), поскольку сложность комманды resize вектора это O(m);
2) Добавление элемента в дэк на вершину/в конец: O(1), поскольку размер вектора фиксирован, а операции по вычислению индекса head или tail выполняются за константное время;
3) Чтение входных значенией длины n: O(n);
В зависимости от подаваемых данных, либо m >= n, либо m < n, следовательно итоговая сложность будет зависеть от максимума из m и n;

Итого: O(max(m,n));

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
1) Для дэка создается вектор фиксированной длины m, следовательно O(m) всегда будет занято;
2) Остальные переменные добавляют константное потребление памяти;
Число входных значений n будет расположено на кольцевом буфере размера m, поэтому максимальный размер потребляемой памяти будет O(m);

Итого: O(m);
*/


#include<iostream>
#include<string>
#include<vector>
#include<stdexcept>
using namespace std;

class Deque {
public:
	Deque(size_t max_size_) {
		max_size = max_size_;
		deque_size = 0;
		head = 0;
		tail = 0;
		ring_buffer.resize(max_size, 0);
	}

	void push_front(int value) {
		if (deque_size < max_size) {
			if (deque_size > 0) {
				head = (head + max_size - 1) % max_size;
			}

			if (deque_size < max_size) {
				deque_size++;
			}
			ring_buffer[head] = value;
		}
		else {
			throw runtime_error("error");
		}
		
	}

	void push_back(int value) {
		if (deque_size < max_size) {
			if (deque_size > 0) {
				tail = (tail + 1) % max_size;
			}

			if (deque_size < max_size) {
				deque_size++;
			}

			ring_buffer[tail] = value;
		}
		else {
			throw runtime_error("error");
		}
	
	}

	int pop_back() {
		if (deque_size > 0) {
			int ret_value = ring_buffer[tail];
			if(deque_size > 1){ tail = (tail - 1 + max_size) % max_size; }
			deque_size--;
			return ret_value;
		}
		else {
			throw runtime_error("error");
		}
	}
	
	int pop_front() {
		if (deque_size > 0) {
			int ret_value = ring_buffer[head];
			if(deque_size > 1){ head = (head + 1) % max_size; }
			deque_size--;
			return ret_value;
		}
		else {
			throw runtime_error("error");
		}
	}


private:
	size_t deque_size, max_size, head, tail;
	vector<int> ring_buffer;	
};

int main() {
	int number_of_commands,  value, result;
	size_t deque_max_size;
	string command;
	cin >> number_of_commands >> deque_max_size;

	Deque deque_task(deque_max_size);
	for (int i = 0; i < number_of_commands; i++) {
		cin >> command;
		try {
			if (command == "push_back") {
				cin >> value;
				deque_task.push_back(value);
			}
			else if (command == "push_front") {
				cin >> value;
				deque_task.push_front(value);
			}
			else if (command == "pop_front") {
				result = deque_task.pop_front();
				cout << result << endl;
			}
			else if (command == "pop_back") {
				result = deque_task.pop_back();
				cout << result << endl;
			}
		}
		catch (runtime_error& err) {
			cout << err.what() << endl;
		}

	}


	return 0;
}