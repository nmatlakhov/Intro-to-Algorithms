/*
https://contest.yandex.ru/contest/22781/run-report/75667977/

-- ПРИНЦИП РАБОТЫ --
Принцип работы идентичен описанному в задаче алгоритму;
1) На основе стандартного динамического контейнера vector написан стэк данных Stack. Предусматривается всего 2 метода: push и pop; 
2) Метод push размещает подаваемый элемент в конце вектора командой push_back и увеличивает размер стэка: stack_size;
3) Метод pop возвращает целое число, если размера стэка положителен и выводит сообщение об ошибке с возвратом фиксированной константы INT8_MIN (хотя этого и не требуется в задаче) иначе;
-----------
4) Инициализируется стэк, добавляются переменные для хранения входных значений;
5) Поскольку на вход подается одна строка, то её забираем с помощью getline. Далее создаем строковый поток на основе прочитанной строки и записываем строковый ввод во временную переменную line;
6) Если строка не является каким-либо из символов: +, -, *, /, то мы считываем число (преобразованием строки в число, через stoi (string to int)) и добавляем его на вершину стэка;
7) Если строка является каким-либо из символов: +, -, *, /, то мы извлекаем операнд (число) из вершины стэка и помещаем его во временную переменную temp_value;
8) Значение операнда удаляется из стэка и на вершине стэка остается второй операнд;
-----------
8) Для операции + прибавляем к temp_value значение второго операнда с вершины стэка;
9) Для операции * умножаем temp_value на значение второго операнда с вершины стэка;
10) Для операции - мы из второго операнда с вершины стэка вычитаем первый операнд, поскольку второй был внесен в стэк ранее (LIFO принцип);
11) Для операции / второй операнд с вершины стэка делим на первый с округлением в сторону минус бесконечности;
	a) Округление в сторону -\infty реализуем отдельной функцией dfloor, поскольку C++ округляет целочисленное деление в сторону нуля; 
	b) При наличии ненулевого остатка от деления (a % b != 0), если один из операндов отрицателен, то их частное тоже будет отрицательным (a*b < 0 => a/b < 0) => нужна корректировка в сторону -\infty;
	c) Если мы находимся в случае b), то функция dfloor вычитает из финального деления 1, чтобы округлить частное в сторону -\infty;
	d) Если остаток нулевой или все операнды положительны, то dfloor возвращает a/b без дополнительного округления (поскольку частное и так будет округлено в сторону -\infty);
-----------
12) Полученный результат мы добавляем в вершину стэка, продолжаем операцию до тех пор, пока не обработаем полный входной набор символов;
13) После обработки ввода, выводим число из вершины стэка, поскольку это и будет нашим результатом расчета;

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Все входные символы будут обработаны, чтение строки будет происходить слева направо и операнды всегда будут размещаться на вершину стэка. Операции будут выполнятся над 
ближайщими двумя значениями из стэка и результат будет обратно добавляться в стэк, затем при наличии операций, процесс повториться. Алгоритм закончится по исчерпанию символов операций.
Результат всех операций будет размещен на вершину стэка и затем выведен в output;

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
1) Добавление в стэк: ~ O(1) амортизированная сложность, поскольку операции push_back это амортизированная O(1) (в худшем случае это O(n));
2) Получение и удаление целого числа из стэка: O(1), поскольку вектору не нужно больше резервировать память, идёт просто получение (копирование) командой back и удаление элемента командой pop_back;
3) Чтение входной строки: O(n) (посимвольно);
4) Простейшие операции с целочисленными типами: O(1);

Итого: временная сложность ~ O(n) по длине входной строки и обработке каждого операнда/символа;

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Если входная строка содержит n1 операндов и n2 символов операций, то в худшем случае стэк будет содержать n1 целых чисел. Поскольку вектор резервирует памяти больше (кажется в два раза), при 
использовании команды push_back, то в худшем случае стэк будет потреблять O(n1). 

Временная строка input_line же будет содержать все n1 + n2 = n символов, поэтому займет памяти O(n).

Остальные элементы будут потреблять константное значение памяти.
*/

#include<iostream>
#include<string>
#include<sstream>
#include<vector>
using namespace std;

int dfloor(int a, int b) {
	int res = a / b;
	int corr = ((a * b < 0) && (a % b != 0));
	return res - corr;
}

class Stack {
public:
	Stack() {
		stack_size = 0;
	}

	void push(int x) {
		stack_container.push_back(x);
		stack_size++;
	}

	int pop() {
		int final_result;
		if (stack_size > 0) {
			final_result = stack_container.back();
			stack_container.pop_back();
			stack_size--;
		}
		else {
			final_result = INT8_MIN;
			cout << "error" << endl;
		}
		return final_result;
	}

private:
	size_t stack_size;
	vector<int> stack_container;
};


int main() {
	Stack stack_values;
	string input_line, line;
	getline(cin, input_line);
	istringstream iss(input_line);
	int temp_value;

	while (iss >> line) {
		if ((line != "+") && (line != "-") && (line != "*") && (line != "/")) {
			stack_values.push(stoi(line));
		}
		else {
			temp_value = stack_values.pop();
			
			if (line == "+") { temp_value += stack_values.pop(); }
			if (line == "-") { temp_value = stack_values.pop() - temp_value;}
			if (line == "*") { temp_value *= stack_values.pop(); }
			if (line == "/") { temp_value = dfloor(stack_values.pop(), temp_value); }
			
			stack_values.push(temp_value);
		}
	}
	
	cout << stack_values.pop() << endl;

	return 0;
}