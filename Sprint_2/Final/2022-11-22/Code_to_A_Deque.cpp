/*
https://contest.yandex.ru/contest/22781/run-report/75676000/

-- ПРИНЦИП РАБОТЫ --
1) На основе стандартного контейнера vector создается класс Deque, в котором мы создаем вектор фиксированной длины (чтобы получить кольцевой буфер) m; 
2) Длина вектора подается при инициализации класса дэка;
3) Чтобы иметь кольцевой буфер по заполнению также инициализируем размер дэка и добавляем новые элементы в вектор, пока размер дэка не достигнет максимального размера;
4) Для методов дэка push_front и push_back используем индексы head и tail при добавлении элементов, поскольку вектор фиксированной длины и можно размещать элементы по этим индексам;
5) По достижению максимального размера дэка при попытке добавить элемент выводится сообщение error;
6) При удалении элементов из дэка (размер дэка > 0), выводится удаляемый элемент и размер дэка уменьшается и мы вновь можем разместить новый элемент на освободившееся место;
7) Если размер дэка был 0, то при удалении элементов выводится сообщение error;

Определение индексов:
a) push_front: при добавлении элемента в вершину дэка, мы должны сместить индекс текущей вершины на один элемент влево (против часовой стрелки), для этого мы из текущего индекса head вычитаем 1
и получаем остаток от деления на максимальный размер дэка max_size. При прохождении элемента через индекс 0 получается отрицательный индекс, в то время как мы хотели бы указывать на индекс m-1, 
для этого добавляется max_size в индекс (получаем положительный вычет), который при неотрицательных значениях head - 1 дает в остатке от деления на самого себя 0;

b) push_back: при добавлении элемента в конец дэка, мы должны сместить индекс текущего конца на один элемент вправо (по часовой стрелке), для этого мы к текущему индекса tail добавляем 1
и получаем остаток от деления на максимальный размер дэка;

c) pop_front: при удалении элемента из вершины дэка, мы должны сместить индекс текущей вершины на один элемент вправо (по часовой стрелке), для этого мы к текущему индекса head добавляем 1
и получаем остаток от деления на максимальный размер дэка max_size;

d) pop_back: при удалении элемента из конца дэка, мы должны сместить индекс текущего конца на один элемент влево (против часовой стрелки), для этого мы из текущего индекса tail вычитаем 1
и получаем остаток от деления на максимальный размер дэка max_size. При прохождении элемента через индекс 0 получается отрицательный индекс, в то время как мы хотели бы указывать на индекс m-1, 
для этого добавляется max_size в индекс (получаем положительный вычет), который при неотрицательных значениях tail - 1 дает в остатке от деления на самого себя 0;

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
При нулевом размере дэка удаление элементов будет выдавать сообщение об ошибке.
При размере дэка равному максимальному добавление элементов будет выдавать сообщение об ошибке.

Добавление элементов в вершину дэка будет сдвигать индекс вершины влево, удаление элементов с вершины дэка будет сдвигать индекс вершины вправо на последовательности: 0, 1, 2, ..., m-1, 
где m - максимальный размер дэка. Поскольку новый индекс получается как остаток от деления на макс.размер m, то получаемое значение будет в диапазоне: (0, ..., m-1) => по этому индексу можно
изменять элемент в векторе размера m, на основе которого построен дэк. 

Аналогично, добавление элементов в конец дэка будет сдвигать индекс вершины вправо, удаление элементов с конца дэка будет сдвигать индекс вершины влево на последовательности: 0, 1, 2, ..., m-1, 
где m - максимальный размер дэка. Поскольку новый индекс получается как остаток от деления на макс.размер m, то получаемое значение будет в диапазоне: (0, ..., m-1) => по этому индексу можно
изменять элемент в векторе размера m, на основе которого построен дэк. 

При удалении всех элементов/инициализации дэка, индексы окажутся в одном месте. Но при первом добавлении элемента индексы будут на разных местах (и так до полного заполнения дэка).
Поскольку индексы вершины сдвигаются влево, а индексы хвоста вправо при добавлении элементов и при их встрече дэка будет заполнена (выведется сообщение об ошибке), то они не будут пересекаться.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
1) Инициализация вектора длины m: O(m), поскольку сложность комманды resize вектора это O(m);
2) Добавление элемента в дэк на вершину/в конец: O(1), поскольку размер вектора фиксирован, а операции по вычислению индекса head или tail выполняются за константное время;
3) Чтение входных значенией длины n: O(n);
В зависимости от подаваемых данных, либо m >= n, либо m < n, следовательно итоговая сложность будет зависеть от максимума из m и n;

Итого: O(max(m,n));

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
1) Для дэка создается вектор фиксированной длины m, следовательно O(m) всегда будет занято;
2) Остальные переменные добавляют константное потребление памяти;
Число входных значений n будет расположено на кольцевом буфере размера m, поэтому максимальный размер потребляемой памяти будет O(m);

Итого: O(m);
*/


#include<iostream>
#include<string>
#include<vector>
using namespace std;

class Deque {
public:
	Deque(size_t max_size_) {
		max_size = max_size_;
		deque_size = 0;
		head = 0;
		tail = 0;
		ring_buffer.resize(max_size, 0);
	}

	void push_front(int value) {
		if (deque_size < max_size) {
			if (deque_size > 0) {
				head = (head + max_size - 1) % max_size;
			}

			if (deque_size < max_size) {
				deque_size++;
			}
			ring_buffer[head] = value;
		}
		else {
			cout << "error" << endl;
		}
		
	}

	void push_back(int value) {
		if (deque_size < max_size) {
			if (deque_size > 0) {
				tail = (tail + 1) % max_size;
			}

			if (deque_size < max_size) {
				deque_size++;
			}

			ring_buffer[tail] = value;
		}
		else {
			cout << "error" << endl;
		}
	
	}

	void pop_back() {
		if (deque_size > 0) {
			cout << ring_buffer[tail] << endl;
			if(deque_size > 1){ tail = (tail - 1 + max_size) % max_size; }
			
			deque_size--;
		}
		else {
			cout << "error" << endl;
		}
	}
	
	void pop_front() {
		if (deque_size > 0) {
			cout << ring_buffer[head] << endl;
			if(deque_size > 1){ head = (head + 1) % max_size; }
			deque_size--;
		}
		else {
			cout << "error" << endl;
		}
	}


private:
	size_t deque_size, max_size, head, tail;
	vector<int> ring_buffer;	
};

int main() {
	int number_of_commands,  value;
	size_t deque_max_size;
	string command;
	cin >> number_of_commands >> deque_max_size;

	Deque deque_task(deque_max_size);
	for (int i = 0; i < number_of_commands; i++) {
		cin >> command;
		if (command == "push_back") {
			cin >> value;
			deque_task.push_back(value);
		}
		else if (command == "push_front") {
			cin >> value;
			deque_task.push_front(value);
		}
		else if (command == "pop_front") {
			deque_task.pop_front();
		}
		else if (command == "pop_back") {
			deque_task.pop_back();
		}

	}


	return 0;
}