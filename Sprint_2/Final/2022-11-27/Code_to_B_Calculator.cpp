/*
https://contest.yandex.ru/contest/22781/run-report/76601051/

-- ПРИНЦИП РАБОТЫ --
Принцип работы идентичен описанному в задаче алгоритму;
1) На основе стандартного динамического контейнера vector написан стэк данных Stack. Предусматривается всего 2 метода: push и pop; 
2) Метод push размещает подаваемый элемент в конце вектора командой push_back и увеличивает размер стэка: stack_size;
3) Метод pop возвращает целое число, если размера стэка положителен и выводит сообщение об ошибке с возвратом фиксированной константы INT8_MIN (хотя этого и не требуется в задаче) иначе;
-----------
4) Инициализируется стэк, добавляются переменные для хранения входных значений;
5) Поскольку на вход подается одна строка, то её забираем с помощью getline. Далее создаем строковый поток на основе прочитанной строки и записываем строковый ввод во временную переменную line;
6) Для простоты будем считывать line с помощью стрового класса stringstream и пробовать извлекать из него в целочисленное значение temp_input, в случае успеха - добавляем элемент в стэк, иначе - идём дальше;
7) Если line является каким-либо из символов: +, -, *, /, то мы извлекаем операнд (число) из вершины стэка и помещаем его во временную переменную temp_value;
8) В случае деления на ноль выводится ошибка Zero division error и программа прекращает работу;
9) Значение операнда удаляется из стэка и на вершине стэка остается второй операнд;
-----------
10) Для операции + прибавляем к temp_value значение второго операнда с вершины стэка;
11) Для операции * умножаем temp_value на значение второго операнда с вершины стэка;
12) Для операции - мы из второго операнда с вершины стэка вычитаем первый операнд, поскольку второй был внесен в стэк ранее (LIFO принцип);
13) Для операции / второй операнд с вершины стэка делим на первый с округлением в сторону минус бесконечности;
	a) Округление в сторону -\infty реализуем отдельной функцией dfloor, поскольку C++ округляет целочисленное деление в сторону нуля; 
	b) При наличии ненулевого остатка от деления (a % b != 0), если один из операндов отрицателен, то их частное тоже будет отрицательным (a*b < 0 => a/b < 0) => нужна корректировка в сторону -\infty;
	c) Если мы находимся в случае b), то функция dfloor вычитает из финального деления 1, чтобы округлить частное в сторону -\infty;
	d) Если остаток нулевой или все операнды положительны, то dfloor возвращает a/b без дополнительного округления (поскольку частное и так будет округлено в сторону -\infty);
-----------
14) Полученный результат мы добавляем в вершину стэка, продолжаем операцию до тех пор, пока не обработаем полный входной набор символов;
15) После обработки ввода, выводим число из вершины стэка, поскольку это и будет нашим результатом расчета;

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Все входные символы будут обработаны, чтение строки будет происходить слева направо и операнды всегда будут размещаться на вершину стэка. Операции будут выполнятся над 
ближайщими двумя значениями из стэка и результат будет обратно добавляться в стэк, затем при наличии операций, процесс повториться. Алгоритм закончится по исчерпанию символов операций.
Результат всех операций будет размещен на вершину стэка и затем выведен в output;

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
1) Добавление в стэк: ~ O(1) амортизированная сложность, поскольку операции push_back это амортизированная O(1) (в худшем случае это O(n));
2) Получение и удаление целого числа из стэка: O(1), поскольку вектору не нужно больше резервировать память, идёт просто получение (копирование) командой back и удаление элемента командой pop_back;
3) Чтение входной строки: O(n) (посимвольно);
4) Простейшие операции с целочисленными типами: O(1);

Итого: временная сложность ~ O(n) по длине входной строки и обработке каждого операнда/символа;

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пусть входная строка содержит: 
 - n1 операнд;
 - n2 символов операций;
 
Временная строка input_line будет содержать n1 + n2 = n символов, поэтому займет памяти O(n). 
Рассмотрим два случая:
(1) Строка содержит только операнды: в данном случае будет n1 = n и стэк займет O(n) памяти;
(2) Строка содержит чередование операндов и операций: в данном случае n1 - 1 = n2, поскольку операндов будет на 1 больше, чем операций и стэк займет максимум O(2) памяти, 
поскольку в нём будет максимум два элемента - левый операнд и правый операнд;
(3) Строка содержит сначала операнды, затем операции таким образом, что все операнды будут использованы: тогда n1 - 1 = n2 и стэк займет максимум O(n1) памяти, по количеству записанных операндов;

Остальные элементы будут потреблять константное значение памяти.

Итого: пространственная сложность ~O(n) по длине входной строки;
*/

#include<iostream>
#include<string>
#include<sstream>
#include<vector>
#include<stdexcept>
using namespace std;

int dfloor(int a, int b) {
	if (b == 0) {
		throw runtime_error("Zero division error");
	}
	else {
		int res = a / b;
		int corr = ((a * b < 0) && (a % b != 0));
		return res - corr;
	}
}

class Stack {
public:
	Stack() {
		stack_size = 0;
	}

	void push(int x) {
		stack_container.push_back(x);
		stack_size++;
	}

	int pop() {
		int final_result;
		if (stack_size > 0) {
			final_result = stack_container.back();
			stack_container.pop_back();
			stack_size--;
		}
		else {
			final_result = INT8_MIN;
			cout << "error" << endl;
		}
		return final_result;
	}

private:
	size_t stack_size;
	vector<int> stack_container;
};


int main() {
	Stack stack_values;
	string input_line, line;
	getline(cin, input_line);
	istringstream iss(input_line);
	int temp_value, temp_input;

	while (iss >> line) {
		if (stringstream(line) >> temp_input) {
			stack_values.push(temp_input);
		}
		else {
			temp_value = stack_values.pop();
			if (line == "+") { temp_value += stack_values.pop(); }
			if (line == "-") { temp_value = stack_values.pop() - temp_value; }
			if (line == "*") { temp_value *= stack_values.pop(); }
			if (line == "/") {
				try { 
					temp_value = dfloor(stack_values.pop(), temp_value); 
				}
				catch (runtime_error& err) {
					cout << err.what() << endl;
					return 0;
				}
			}
			stack_values.push(temp_value);
		}
	}
	
	cout << stack_values.pop() << endl;

	return 0;
}