/*
https://contest.yandex.ru/contest/26133/run-report/84110566/
ПРИНЦИП РАБОТЫ:
1) Рекурсивный разворот запакованной строки в полную/обычную строку;
2) Находим минимальную и максимальную строки;
3) Посимвольно проверяем две строки, пока либо не достигнем минимальной длины строки => общий префикс = одной из двух строк, либо пока не попадется первый отличный символ;
4) Во время проверки составляем результирующую строку и выводим;

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
1) При поиске максимальной и минимальной строк, строки будут упорядочены в лексикографическом порядке, соответственно, если есть наибольший общий префикс, то он будет одинаков, как для самой 
меньшей строки, так и для самой большей. Для всех строк между общий префикс будет одинаков, как раз из-за лексикографического порядка;
2) Производя посимвольное сравнение, мы либо ищем первое несовпадение символов => вплоть до этого символа префикс будет одинаковый, либо ищем конец строки =>
строка будет общим префиксом для всех остальных строк между;

ВРЕМЕННАЯ СЛОЖНОСТЬ: 
Пусть всего n - число строк, длина строки после распаковки не выше, чем m, следовательно распаковка 1-ой строки будет занимать в худшем случае O(m), когда у всех строк будет одинаковая длина:
1) Рекурсивный разворот запакованных строк в худшем случае: ~O(nm);
2) Посимвольное сравнение строк для поиска наибольшей и наименьшей строки: в худшем случае ~O(nm)
3) Посимвольное сравнение двух строк в худшем случае: ~O(m);
Итого: ~O(nm)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
Пусть всего n - число строк, длина строки после распаковки не выше, чем m, следовательно распакова 1-ой строки будет занимать в худшем случае O(m):
1) Рекурсивный разворот запакованных строк в худшем случае: ~O(nm), поскольку распаковка производится рекурсивно, то также будет использоваться доп. память, но её порядок
не будет превышать O(nm), поскольку рекурсия не будет вызываться большее число раз, чем символов в строке;
2) Хранение минимальной и максимальной строки: в худшем случае ~O(m)
Итого: ~O(nm)

*/

#include<string>
#include<iostream>
using namespace std;

string unpack_string(string text, int multiply) {
	char s;
	string result = "", final_result = "";
	int n = text.size(), j = 0, mult_next = 0, count = 0;

	while(j < n) {
		if (isdigit(text[j])) {
			mult_next = text[j] - '0';
			j++;
		}

		if (text[j] == '[') {
			count++;
			j++;

			string temp = "";
			while (count > 0) {
				if (text[j] == '[') { count++; }
				if (text[j] == ']') { count--; }
				if (count == 0) { j++; break; }
				temp += text[j];
				
				j++;
			}

			result += unpack_string(temp, mult_next);
		}

		if (isalpha(text[j])) {
			result += text[j];
			j++;
		}

	}
	
	
	for (int i = 0; i < multiply; i++) {
		final_result += result;
	}


	return final_result;
}

string largest_common_prefix(string max_string, string min_string) {
	string result = "";
	int min_dist = min_string.size();

	int i = 0;
	while ((i < min_dist) && (min_string[i] == max_string[i])) {
		result += min_string[i];
		i++;
	}
	return result;
}

int main() {
	int n;
	cin >> n >> ws;
	string temp,line,  min_string = "", max_string;

	for (int i = 0; i < n; i++) {
		getline(cin, line);
		temp = move(unpack_string(line, 1));
		if (i == 0) { 
			min_string = temp;
			max_string = temp;
		}
		if (min_string > temp) {
			min_string = temp;
		}
		if (max_string < temp) {
			max_string = temp;
		}
	}

	string result = largest_common_prefix(max_string,min_string);

	cout << result << endl;

	return 0;
}