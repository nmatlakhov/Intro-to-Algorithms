/*
https://contest.yandex.ru/contest/26133/run-report/84059091/
ПРИНЦИП РАБОТЫ:
1) Рекурсивный разворот запакованной строки в полную/обычную строку;
2) Записываем все полные строки в вектор и сортируем его;
3) Возьмем первую строчку из сортированного вектора и последнюю. Найдем минимальную длину из двух строк;
4) Посимвольно проверяем две строки, пока либо не достигнем минимальной длины строки => общий префикс = одной из двух строк, либо пока не попадется первый отличный символ;
5) Во время проверки составляем результирующую строку и выводим;

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
1) При сортировке, все символы будут располагаться в лексикографическом порядке, соответственно, если есть наибольший общий префикс, то он будет одинаков, как для самой 
меньшей лексикографической строки, так и для самой большей. Для всех строк между общий префикс будет одинаков, как раз из-за лексикографического порядка строк;
2) Производя посимвольное сравнение, мы либо ищем первое несовпадение символов => вплоть до этого символа префикс будет одинаковый, либо ищем конец строки =>
строка будет общим префиксом для всех остальных строк между;

ВРЕМЕННАЯ СЛОЖНОСТЬ: 
Пусть всего n - число строк, длина строки после распаковки не выше, чем m, следовательно распакова 1-ой строки будет занимать в худшем случае O(m), когда у всех строк будет одинаковая длина:
1) Рекурсивный разворот запакованных строк в худшем случае: ~O(mn);
2) Сортировка вектора из полных строк в худшем случае: ~O(nm log(nm));
3) Посимвольное сравнение строк в худшем случае: ~O(nm);
Итого: ~O(nm log(nm))

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
Пусть всего n - число строк, длина строки после распаковки не выше, чем m, следовательно распакова 1-ой строки будет занимать в худшем случае O(m):
1) Рекурсивный разворот запакованных строк в худшем случае: ~O(mn), поскольку распаковка производится рекурсивно, то также будет использоваться доп. память, но её порядок
не будет превышать O(mn), поскольку рекурсия не будет вызываться большее число раз, чем символов в строке;
2) Хранение вектора из полных строк: ~O(nm);
Итого: ~O(nm)

*/

#include<string>
#include<vector>
#include<iostream>
#include<algorithm>
#include<utility>
using namespace std;

string unpack_string(string text, int multiply) {
	char s;
	string result = "", final_result = "";
	int n = text.size(), j = 0, mult_next = 0, count = 0;

	while(j < n) {
		if (isdigit(text[j])) {
			mult_next = text[j] - '0';
			j++;
		}

		if (text[j] == '[') {
			count++;
			j++;

			string temp = "";
			while (count > 0) {
				if (text[j] == '[') { count++; }
				if (text[j] == ']') { count--; }
				if (count == 0) { j++; break; }
				temp += text[j];
				
				j++;
			}

			result += unpack_string(temp, mult_next);
		}

		if (isalpha(text[j])) {
			result += text[j];
			j++;
		}

	}
	
	
	for (int i = 0; i < multiply; i++) {
		final_result += result;
	}


	return final_result;
}

string largest_common_prefix(vector<string>& strs) {
	sort(strs.begin(), strs.end());
	int n = strs.size();

	string first = strs[0], last = strs[n - 1],result = "";
	int min_dist = min(first.size(), last.size());

	int i = 0;
	while ((i < min_dist) && (first[i] == last[i])) {
		result += first[i];
		i++;
	}
	return result;
}

int main() {
	int n;
	cin >> n >> ws;
	string temp;

	vector<string> strs(n, "");

	for (int i = 0; i < n; i++) {
		getline(cin, temp);
		strs[i] = move(unpack_string(temp, 1));
	}

	string result = largest_common_prefix(strs);

	cout << result << endl;

	return 0;
}