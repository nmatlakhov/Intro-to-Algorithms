/*
https://contest.yandex.ru/contest/26133/run-report/84060093/
ПРИНЦИП РАБОТЫ:
Создаем префиксное дерево из допустимых к использованию слов и посимвольно прикладываем его к нашему тексту. 
Отмечаем в массиве динамического программирования все места, где возможно разбиение на слова. Проходимся по всему тексту, прикладывая бор. Ответ на вопрос о возможности разбиения текста
будет находится в последней ячейке этого массива.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
1) Считываем строку с текстом;
2) Создается префиксное дерево из допустимых к использованию слов. С помощью бора мы будем искать слова определенной длины в множестве шаблонов;
3) Создается массив динамического программирования из булевых переменных - dp, размера массива = размеру текста;
	а) В массиве будут хранится ответы на подзадачи: можно ли имея текущий бор разбить текст длины i на слова из этого бора;
	б) Базовый случай - разбиение текста длины 0 => возможно разбиение с любым бором => true;
	в) В переходе динамики мы будем смотреть, если возможно разбить текст длины i на слова из бора, можно ли будет найти ещё какие-то слова длины k1, k2, ..., чтобы текст длины i + k1, i + k2,...
	также разбивался на слова из бора;
	г) Массив будет заполняться по порядку, начиная с текста длины 0, заканчивая текстом полной длины;
	д) Ответ на наш вопрос, можно ли разбить исходный текст на слова из бора будет находиться в последней ячейке массива;
 

ВРЕМЕННАЯ СЛОЖНОСТЬ:
Пусть у нас текст длины n символов. Пусть N - число слов из маленьких латинских букв и M - максимальная длина каждого из слова.
1) Считывание текста ~O(n);
2) Считывание слов и построение бора: ~O(NM);
3) Построение динамического массива dp: ~O(n);
4) Прикладывание бора к тексту - всего n символов, на каждом символе число проверок будет не больше, чем длина самого длинного слова - M => сложность: ~O(nM);
Итого: ~O((N + n)*M)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
Пусть у нас текст длины n символов. Пусть N - число слов из маленьких латинских букв и M - максимальная длина каждого из слова.
1) Считывание текста ~O(n);
2) Считывание слов и построение бора: ~O(NM);
3) Построение динамического массива dp: ~O(n);
Итого: ~O(NM + n)

*/

#include<string>
#include<iostream>
#include<vector>
using namespace std;

struct TrieNode {
	TrieNode* children[26] = { nullptr };
	bool is_terminal = false;

};

void add_string(TrieNode* root, string line) {
	TrieNode* current_node = root;
	int n = line.size();

	int id;
	for (int i = 0; i < n; i++) {

		id = line[i] - 'a';

		if (current_node->children[id] == nullptr) {
			TrieNode* new_node = new TrieNode;
			current_node->children[id] = new_node;
		}
		current_node = current_node->children[id];
	}

	current_node->is_terminal = true;

}


bool is_breakable(TrieNode* const root, string text) {
	int n = text.size();
	vector<bool> dp(n + 1,false);
	dp[0] = true;

	for (int i = 0; i < n; i++) {
		if (dp[i]) {
			TrieNode* current_node = root;

			for (int j = i; j < n; j++) {
				if (current_node == nullptr) { break; }
				current_node = current_node->children[text[j] - 'a'];

				if (current_node != nullptr) {
					if (current_node->is_terminal) {
						dp[j + 1] = true;
					}
					
				}

			}
		}
	}


	return dp[n];
}

int main() {
	string text, temp;
	getline(cin, text);

	int n;
	cin >> n >> ws;

	TrieNode* root = new TrieNode;

	for (int i = 0; i < n; i++) {
		getline(cin, temp);
		add_string(root, temp);
	}

	if (is_breakable(root, text)) {
		cout << "YES" << endl;
	}
	else {
		cout << "NO" << endl;
	}

	return 0;
}