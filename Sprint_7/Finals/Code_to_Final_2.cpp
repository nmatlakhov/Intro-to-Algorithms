/*
https://contest.yandex.ru/contest/25597/run-report/83485569/
ПРИНЦИП РАБОТЫ:
Пусть сумма выигранных партий = sum, тогда разделение вектора будем проводить на двумерном массиве dp бинарных значений размера (n + 1)*(sum +1)
1) Сначала проверяем, что сумма выигранных партий делится на 2, если не делится => точно нельзя разделить на две части число выигранных партий;
2) Далее мы сумму делим на 2: half_sum = sum /2 и будем проверять, сможем ли мы получить эту сумму выбрав ряд чисел из нашего набора;
3) В dp будем хранить флаг возможности получения искомой суммы. В ячейке dp[i][j] будет хранится флаг возможности получения суммы j, имея поднабор выигрышных партий от 0 до i-1;

4) Базовый случай: сумма чисел равна 0 и количество чисел тоже 0 => пустое разделение => возвращаем True;
5) Если сумма равна 0 => все числа в векторе = 0 => в этом случае возвращаем True (поскольку можно разделить вектор из нулей) => для каждого i, dp[i][0] = True;
6) Если сумма > 0, но вектор пуст => невозможно разделить пустой вектор на части, чтобы получить положительную сумму => dp[0][j] = False (j > 0);
7) Переход динамики: добавление нового числа выигранных партий в поднабор чисел + увеличение суммы на 1:
	а) Если сумма j меньше добавленного числа, то флаг возможности берем для этой же суммы j, но из предыдущего поднабора из i-1 элемента: dp[i][j] = dp[i-1][j];
	б) Если сумма j больше добавленного числа, то флаг возможности составляется из двух элементов: либо возможности собрать сумму из предыдущего поднабора - dp[i-1][j], либо 
	из возможности собрать остаток от разности суммы и добавленного числа (j - nums[i-1]) в предыдущем поднаборе - dp[i-1][j - nums[i-1]]: dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
8) Ответ будет хранится в последней ячейке нашего массива, поскольку там мы будем иметь весь поднабор и рассматривать требуемую сумму;

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
Решение будет верным, поскольку на каждом шаге мы будем выбирать возможность составить требуемую сумму из рассматриваемого поднабор выигрышных партий.
На каждом шаге в ячейке dp будет находиться флаг возможности собрать некоторую сумму из выбранного поднабора чисел => в ячейке dp[n][half_sum] будет находиться 
флаг возможности собрать сумму half_sum из поднабора n чисел (т.е. всего вектора выигрышных партий);

ВРЕМЕННАЯ СЛОЖНОСТЬ:
Пусть сумма выигранных партий = sum. Половина суммы: half_sum = sum /2;
1) Считывание вектор размера n: ~O(n);
2) Подсчет суммы по вектору: ~O(n);
3) Создание массива dp размера (n + 1)*(half_sum + 1): ~O((n + 1)*(half_sum + 1) = ~O(n*half_sum + n + half_sum + 1) = ~ O(n*half_sum);
4) Проставление флага true для вектора нулевой длины: ~O(half_sum + 1);
5) Переход динамики: ~O(n*half_sum);
Итого: ~O(n*half_sum)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
Пусть сумма выигранных партий = sum. Половина суммы: half_sum = sum /2;
1) Считывание вектор размера n: ~O(n);
2) Создание массива dp размера (n + 1)*(half_sum + 1): ~O((n + 1)*(half_sum + 1) = ~O(n*half_sum + n + half_sum + 1) = ~ O(n*half_sum);
Итого: ~O(n*half_sum)

*/


#include<vector>
#include<iostream>
using namespace std;

bool checkSplit(vector<int>& nums) {
	int sum = 0, n = nums.size(), half_sum = 0;
	bool result;

	for (int i = 0; i < n; i++) {
		sum += nums[i];
	}

	if (sum % 2 != 0) { return false; }
	half_sum = sum / 2;
		
	vector<vector<bool>> dp(n + 1, vector<bool>(half_sum + 1, false));
	dp[0][0] = true;

	for (int i = 1; i <= n; i++) {
		dp[i][0] = true;
	}

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= half_sum; j++) {
			if (j - nums[i - 1] < 0) {
				dp[i][j] = dp[i - 1][j];
			}
			else {
				dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
			}
		}
	}

	result = dp[n][half_sum];

	return result;
}

int main() {
	int n, temp_val;
	cin >> n;
	
	vector<int> nums(n, 0);

	for (int i = 0; i < n; i++) {
		cin >> temp_val;
		nums[i] = temp_val;
	}

	if (checkSplit(nums)) {
		cout << "True" << endl;
	}
	else {
		cout << "False" << endl;
	}

	return 0;
}