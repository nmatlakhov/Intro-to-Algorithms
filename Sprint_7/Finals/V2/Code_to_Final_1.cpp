/*
https://contest.yandex.ru/contest/25597/run-report/83542362/
ПРИНЦИП РАБОТЫ:
Согласно задаче, мы можем привести одну строку к другой, либо удалением символа, либо вставкой нового символа, либо заменой одного символа на другой.
На вход подается две строки длинами m и n соответственно.

1) В массиве dp будет хранится расстояние Левенштейна (РЛ) для подстрок длиной i и j в ячейке dp[i % 2][j]. 
Чтобы сэкономить память массив будет представлять из себя срез двумерного массива из 2х строк => его размер: 2*(n+1);

2) Если вторая строка пустая, то расстояние Левенштейна для другой подстроки будет равно её длине, например: line1 = "abc" и line2 = "" => расстояние Левенштейна = 3, поскольку
необходимо к пустой строке добавить три новых символа => dp[0][j] будут заполнятся длиной подстрок = j;

3) В процессе перехода мы удлиняем одну из строк на один символ. Динамика перехода будет идти по строке (можно сделать по столбцу) так, чтобы были известны значения РЛ на предыдущей строк:
	а) При переходе на новую строку в матрице dp, мы устанавливаем значение в ячейке dp[i % 2][0] = i, поскольку это РЛ для пустой первой строки => равно длине второй строки;
	б) При переходе на новый шаг, где мы рассматриваем подстроки длиной i и j, сначала мы смотрим совпали ли на новом шаге символы строк на i-ом и j-ом месте (line1[i-1] == line2[j-1]). 
		(1) Если символы совпали => РЛ не увеличивается относительно подстрок длиной i-1 и j-1 (вставка совпадающего символа) => смотрим ячейку dp[(i-1) % 2][j-1];
		(2) Если символы разные => РЛ увеличивается на 1 относительно подстрок длиной i-1 и j-1, поскольку требуется замена одного символа на другой (замена) => смотрим ячейку dp[(i-1) % 2][j-1];
	в) Смотрим, что будет в случае удаления символа из 1-ой строки => PЛ увеличивается на 1 относительно подстрок длиной i-1 и j (удаление символа) => смотрим ячейку dp[(i-1) % 2][j];
	г) Смотрим, что будет в случае удаления символа из 2-ой строки => PЛ увеличивается на 1 относительно подстрок длиной i и j-1 (удаление символа) => смотрим ячейку dp[i % 2][j-1];

4) Таким образом, на каждом шаге мы смотрим, что лучше сделать: добавить символ, добавить символ и заменить его, удалить символ из 1-ой или 2-ой строки;
5) Расстояние Левенштейна для двух строк будет находиться в ячейке dp[m % 2][n], как РЛ для двух строк = полным подстрокам;

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
Решение будет верным, поскольку на каждом шаге мы будем выбирать минимальное расстояние Левенштейна среди возможных трех вариантов действий со строками и будем двигаться по 2м строчкам динамического 
массива размера (m+1)*(n+1) => объем памяти не превысти ~O(n); На каждом шаге в ячейке dp будет находиться РЛ конкретных подстрок => в ячейке dp[m % 2][n] 
будет находиться РЛ для подстрок максимальной длины (т.е. самих подстрок), когда мы окажемся на нижних 2-х строчках дин. массива размера (m+1)*(n+1);

ВРЕМЕННАЯ СЛОЖНОСТЬ:
1) Чтение строк длины m и n: ~O(m + n)
2) Создание двумерного массива, размера 2*(n+1): ~O(n)
3) Прохождение по 0 строке и по 0 столбцу: ~O(m + n)
4) Прохождение по каждому символу строки 1 для каждого символа строки 2: ~O(mn)
Итого: ~O(mn)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
1) Чтение строк длины m и n: ~O(m + n)
2) Создание массива, размера 2*(n+1): ~O(2*(n+1)) ~O(n)
Итого: ~O(m + n)

*/


#include<string>
#include<iostream>
#include<vector>
using namespace std;

int min(int x, int y, int z) { return min(min(x, y), z); }

int EditDistDp(string line1, string line2) {
	int m = line1.size();
	int n = line2.size();

	vector<vector<int>> dp(2, vector<int>(n + 1, 0));

	for (int j = 1; j<= n; j++) {
		dp[0][j] = j;
	}

	for (int i = 1; i <= m; i++) {
		dp[i % 2][0] = i;
		for (int j = 1; j <= n; j++) {
			int value = 1;
			if (line1[i - 1] == line2[j - 1]) {
				value = 0;
			}

			dp[i % 2][j] = min(dp[(i - 1) % 2][j] + 1, dp[i % 2][j - 1] + 1, dp[(i - 1) % 2][j - 1] + value);
		}
	}

	return dp[m % 2][n];
}


int main() {
	string line, line2;
	getline(cin, line);
	getline(cin, line2);

	int result = EditDistDp(line, line2);

	cout << result << endl;

	return 0;
}