/*
https://contest.yandex.ru/contest/25597/run-report/82762500/
ПРИНЦИП РАБОТЫ:
Согласно задаче, мы можем привести одну строку к другой, либо удалением символа, либо вставкой нового символа, либо заменой одного символа на другой.
На вход подается две строки длинами m и n соответственно.

1) В массиве dp будет хранится расстояние Левенштейна (РЛ) для подстрок длиной i и j соответственно. Массив будет размера (n+1)*(m+1)
2) Если одна из строк пустая, то расстояние Левенштейна для другой подстроки будет равно её длине, например: line1 = "" и line2 = "abc" => расстояние Левенштейна = 3, поскольку
необходимо к пустой строке добавить три новых символа => dp[0][j] и dp[i][0] будут заполнятся длиной подстрок = i и j соответственно
3) Процесс перехода динамики похож на поиск НОП для строк. В процессе перехода мы удлиняем одну из строк на один символ.
	а) При переходе на новый шаг, где мы рассматриваем подстроки длиной i и j, сначала мы смотрим совпали ли на новом шаге символы строк на i-ом и j-ом месте (line1[i-1] == line2[j-1]). 
		(1) Если символы совпали => РЛ не увеличивается относительно подстрок длиной i-1 и j-1 (вставка совпадающего символа);
		(2) Если символы разные  => РЛ увеличивается на 1 относительно подстрок длиной i-1 и j-1, поскольку требуется замена одного символа на другой (замена);
	б) Смотрим, что будет в случае удаления символа из 1-ой строки => PЛ увеличивается на 1 относительно подстрок длиной i-1 и j (удаление символа);
	в) Смотрим, что будет в случае удаления символа из 2-ой строки => PЛ увеличивается на 1 относительно подстрок длиной i и j-1 (удаление символа);

4) Таким образом, на каждом шаге мы добавляем новый символ, смотря на то, что лучше сделать: добавить символ, добавить символ и заменить его, удалить символ из 1-ой или 2-ой строки.
5) Расстояние Левенштейна для двух строк будет находиться в ячейке dp[n][m], как РЛ для двух строк = полным подстрокам.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
Решение будет верным, поскольку на каждом шаге мы будем выбирать минимальное расстояние Левенштейна среди возможных трех вариантов действий со строками. 
На каждом шаге в ячейке dp будет находиться РЛ конкретных подстрок => в ячейке dp[n][m] будет находиться РЛ для подстрок максимальной длины (т.е. самих подстрок).

ВРЕМЕННАЯ СЛОЖНОСТЬ:
1) Чтение строк длины m и n: ~O(m + n)
2) Создание двумерного массива, основанного на строках длины m и n, размера (m+1)*(n+1): ~O(mn + n + m + 1) ~O(mn)
3) Прохождение по 0 строке и по 0 столбцу: ~O(m + n)
4) Прохождение по каждой ячейке двумерного массива: ~O(mn)
Итого: ~O(mn)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
1) Чтение строк длины m и n: ~O(m + n)
2) Создание двумерного массива, основанного на строках длины m и n, размера (m+1)*(n+1): ~O(mn + n + m + 1) ~O(mn)
Итого: ~O(mn)

*/


#include<string>
#include<iostream>
#include<vector>
using namespace std;

int min(int x, int y, int z) { return min(min(x, y), z); }

int EditDistDp(string line1, string line2) {
	int m = line1.size();
	int n = line2.size();

	vector<vector<int>> dp(m + 1, vector<int>(n + 1,0));

	for (int i = 1; i <= m; i++) {
		dp[i][0] = i;
	}

	for (int i = 1; i <= n; i++) {
		dp[0][i] = i;
	}

	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			int value = 1;
			if (line1[i - 1] == line2[j - 1]) {
				value = 0;
			}

			dp[i][j] = min( dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + value );
		}
	}

	return dp[m][n];
}

int main() {
	string line1, line2;
	getline(cin, line1);
	getline(cin, line2);

	int result = EditDistDp(line1, line2);

	cout << result << endl;

	return 0;
}