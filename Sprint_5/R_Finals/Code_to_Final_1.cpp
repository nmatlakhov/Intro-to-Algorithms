/* https://contest.yandex.ru/contest/24810/run-report/81721555/  */
/*
ПРИНЦИП РАБОТЫ:
За основу была взята одна из финальных задач про сортировку. Определяется структура участника (participant), и на ней задается линейный порядок, соответствующий описанному в задаче. 
После чего были реализованы функции heapAdd, popMax, heapSort в соответствии с описанием в статье "Приоритетная очередь. Вставка и удаление"
https://practicum.yandex.ru/learn/algorithms/courses/7f101a83-9539-4599-b6e8-8645c3f31fad/sprints/88123/topics/e7dbf42a-fd5a-434b-990d-9cfe0e3a10c8/lessons/116802f2-0842-4195-9d12-13e7bf0efad1/

Сортировка реализована в убывающем порядке. После чего выводятся имена участников по всему вектору функцией printSortVector.


ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:

1) Создается класс участник: participant, на котором перегружаются операции сравнения: <;

2) Участник a < участника b, если верен один из следующих пунктов:
	а) # решенных задач a < # решенных задач b;
	б) (# решенных задач a == # решенных задач b) и (штраф a > штраф b);
	в) (# решенных задач a == # решенных задач b) и (штраф a == штраф b) и (имя a > имя b в лексикографическом смысле, то есть имя b идёт раньше, чем a);
Реализация сравнения строк в C++ предполагает возврат true для string a < string b, если a лексикографически раньше, чем b;

3) После заведения класса участника и перегрузки операций сравнения я добавил функции siftUp, siftDown, heapAdd, popMax, heapSort. Первые две осуществляют просеивание приоритетной очереди после
добавления и удаления элемента соответственно. heapAdd добавляет элемент в очередь, popMax удаляет элемент из очереди. (очередь читай как дерево на массиве в данной реализации). Коментарии по siftUp,
siftDown, heapAdd, popMax, heapSort даны по коду;

4) Считываются данные участников в вектор students, затем вектор подается в функцию heapSort, после чего получаем упорядоченный (по убыванию) вектор студентов;

5) Функцией printSortVector пройдемся по каждому участнику и выведем его имя;

ВРЕМЕННАЯ СЛОЖНОСТЬ:
1) Предположим, что у нас n участников, тогда на вход будет подаваться n записей, каждая из которых содержит до 20 символов текста и ровно 2 числа к ним => сложность записи на каждого из участников
будет равна максимум 22 по линейности строки и двум числам => сложность записи n участников O(22n);

2) Алгоритм пирамидальной сортировки в худшем случае работает за небольше, чем O(n log(n)). Добавление i-го элемента в кучу занимает O(log i) временной сложности.
Поэтому добавление m элементов (смотри в курсе) займет:
O(log 1) + O(log 2) + ... + O(log n) <= O(log n) + O(log n) + ... + O(log n) = O(n log (n))

3) Извлечение m элементов из бинарной кучи также займет в худшем случае не больше, чем O(n log(n))
Итого: временная сложность в худшем случае не больше, чем O(n log(n))

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
1) Каждая структура участника имеет сложность не больше 22 (20 на логин и 2 на штрафы и число решенных задач). Всего таких структур в векторе будет равно n => пространственная сложность
будет порядка O(22n), также будет создан дополнительный массив для кучи и записи его результата. Массив для кучи займет порядка O(22n). Затем элементы кучи будут перенесены в новый массив, а сама куча
будет уменьшаться (за счет pop_back операции);

2) Результаты пирамидальной сортировки будут записаны в новый вектор, поэтому всего будет задействовано 4 массива размера порядка O(22n); 

3) Если строки максимум могут иметь длину 20 => размер строки будет как минимум 20 байт, + ещё 8 байт на два целых значения => при n = 100,000 мы получим не менее 2,800,000 байт занятой памяти =>
=> 2,800,000/(1024^2) =~ 2,67 МБ, т.е. в худшем случае будет занято не меньше 3 МБ на один массив;

4) Итого: пространственная сложность имеет порядок ~ O(bn) в худшем случае, где b <= 24;

Обобщая: пространственная сложность ~O(n). Дополнительная память используется при создании кучи (порядка O(n)) и массива для записи результата.

*/

#include<vector>
#include<iostream>
#include<string>
#include<utility>
using namespace std;

struct participant {
	string part_name;
	int nsolved;
	int penalty;
	participant() : part_name(""), nsolved(0), penalty(0) {}
	participant(string name_, int nsol, int penalt) : part_name(name_), nsolved(nsol), penalty(penalt) {}
};

using Iterator = vector<participant>::iterator;

bool operator<(const participant& lhs, const participant& rhs) {
	if (lhs.nsolved < rhs.nsolved) {
		return true;
	}
	else if (lhs.nsolved == rhs.nsolved) {
		if (lhs.penalty > rhs.penalty) {
			return true;
		}
		else if (lhs.penalty == rhs.penalty) {
			if (lhs.part_name > rhs.part_name) {
				return true;
			}
		}
	}
	return false;
}

int siftDown(vector<participant>& heap, int idx) {
	/*Просеивание вниз очереди heap при удалении элемента по индексу idx*/

	//Размер кучи искусственно занижается на 1, чтобы было удобнее оперировать с индексами и пропустить 1-ый элемент 
	int hsize = heap.size() - 1;

	//Получение индексов левого и правого потомков ноды (узла) с индексом idx
	int left = 2 * idx;
	int right = 2 * idx + 1;

	//Временная переменная для хранения индекса ноды (узла) потомка с максимальным значением
	int idx_largest;

	//Если размер кучи меньше индекса левого потомка, то у текущего узла их нет и функция вернут индекс текущего элемента
	if (hsize < left) { return idx; }

	//Если размер кучи больше индекса правого потомка, то по свойствам бинарной кучи у узла есть потомки
	//Находим индекс потомка с наибольшим значением
	if (right <= hsize) {
		if (heap[left] < heap[right]) {
			idx_largest = right;
		}
		else {
			idx_largest = left;
		}
	}
	else {
		idx_largest = left;
	}
	//Временная переменная для записи нового индекса после просеивания вниз
	int return_idx = idx;

	//Если значение в узле меньше, чем значение в его потомке, то мы поменяем потомка и родителя местами
	if (heap[idx] < heap[idx_largest]) {

		//Меняем местами родителя и потомка
		swap(heap[idx], heap[idx_largest]);
		
		//Проводим просеивание дальше, пока значение потомка не окажется меньше значения родителя (чтобы получилась невозрастающая пирамида)
		return_idx = siftDown(heap, idx_largest);
	}

	return return_idx;
}

/*Просеивание вверх очереди heap при добавлении элемента по индексу idx*/
int siftUp(vector<participant>& heap, int idx) {
	
	//Если элемент это корень - завершаем работу
	if (idx <= 1) { return idx; }

	//Вычисляем индекс родителя (деление целочисленное => не пользуемся функциями для округления)
	int parent_idx = idx / 2;

	//Временная переменная для записи нового индекса после просеивания вверх
	int return_idx = idx;

	//Если родитель элемента по значению меньше, чем элемент, то меняем их местами
	if (heap[parent_idx] < heap[idx]) {

		//Временная нода
		swap(heap[idx], heap[parent_idx]);

		//Рекурсивно вызываем функцию на уже родительский узел после замены
		return_idx = siftUp(heap, parent_idx);
	}

	//Возвращение индекса узла, после его просеивания
	return return_idx;
}

/*Добавление элемента в приоритетную очередь*/
void heapAdd(vector<participant>& heap, participant& item) {
	
	//Вычисляем текущий размер очереди, поскольку имеено на место с этим индексом будет добавлен новый элемент
	int idx = heap.size();

	//Добавление нового элемента
	heap.push_back(item);

	//Просеивание добавленного элемента вверх
	siftUp(heap, idx);
}

/*Удаление самого приоритетного элемента из очереди и возврат этого значения функцией*/
participant popMax(vector<participant>& heap) {

	//Получение самого приоритетного элемента, запись его во временную переменную
	participant result = heap[1];

	//Замена самого приоритетного элемента самым последним элементов в очереди (чтобы сохранялось свойство упорядоченности бинарной кучи)
	int idx = heap.size() - 1;
	heap[1] = heap[idx];

	//Удаление последнего элемента из бинарной кучи и просеивание его вниз
	heap.pop_back();
	siftDown(heap, 1);

	//Возвращение функцией самого приоритетного элемента до замены и просеивания
	return result;
}

/*Пирамидальная сортировка*/
vector<participant> heapSort(Iterator begin, Iterator end) {

	//Создаем два вектора: первый - бинарная куча, куда добавляется 1 пустой элемент (для работы с индексами) и массив в который будут складывается упорядоченные элементы
	vector<participant> heap(1), sortedVector;

	//Добавляем в бинарную кучу (end - begin) элементов
	for (auto it = begin; it != end; it++) {
		heapAdd(heap, *it);
	}

	//До тех пор пока куча не пустая (не содержит первый пустой элемент) будем вытаскивать из неё наиболее приоритетные элементы
	while (heap.size() > 1) {
		sortedVector.push_back(move(popMax(heap)));
	}
	return sortedVector;
}


void printSortVector(const vector<participant>& result) {
	int n = result.size();
	for (int i = 0; i < n; i++) {
		cout << result[i].part_name << endl;
	}
}

int main() {
	int n;
	cin >> n;
	vector<participant> students(n);

	string temp_string;
	int temp_sol, temp_penalty;
	for (int i = 0; i < n; i++) {
		cin >> temp_string >> temp_sol >> temp_penalty;
		participant temp_p(temp_string, temp_sol, temp_penalty);
		students[i] = move(temp_p);
	}
	students = move(heapSort(students.begin(), students.end()));

	printSortVector(students);
	return 0;
}