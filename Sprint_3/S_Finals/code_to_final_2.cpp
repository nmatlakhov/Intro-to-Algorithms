/* https://contest.yandex.ru/contest/23815/run-report/78793124/  */
/*
ПРИНЦИП РАБОТЫ:
Определяется структура участника (participant), и на ней задается линейный порядок, соответствующий описанному в задаче. После чего была реализована 
функция inplaceQuickSort в соответствии с описанием в задаче, где опорным элементом каждый раз выбирается медиана из начала, конца и середины вектора с участниками. Сортировка реализована
в убывающем порядке. После чего выводятся имена участников по всему вектору функцией printSortVector.

Также были использованы методы выбора опорного элемента: случайный, просто середина. Финальная реализация использует медианный опорный элемент.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:

1) Создается класс участник: participant, на котором перегружаются операции сравнения: <;

2) Участник a < участника b, если верен один из следующих пунктов: 
	а) # решенных задач a < # решенных задач b;
	б) (# решенных задач a == # решенных задач b) и (штраф a > штраф b);
	в) (# решенных задач a == # решенных задач b) и (штраф a == штраф b) и (имя a > имя b в лексикографическом смысле, то есть имя b идёт раньше, чем a);
Реализация сравнения строк в C++ предполагает возврат true для string a < string b, если a лексикографически раньше, чем b;

3) После заведения класса участника и перегрузки операций сравнения я добавил функции inplaceQuickSort, vectorPartition и get_median. Первая есть реализация алгоритма быстрой сортировки,
вторая есть реализация разделения массива на две части по опорному элементу, и последняя есть реализация получения медианы из трех элементов;

inplaceQuickSort
4) Принимает на вход итераторы начала и конца вектора участников (в формате полуинтервала [begin, end) ). 
Базовый случай: начало и конец интервала совпадают (на тестах этот базовый случай показал лучший результат), можно также поставить условие end - begin < 2 и это будет возможно, поскольку
такая операция поддерживается для случайных итераторов вектора, но правильности ради будем использовать == (к тому же тесты на таком базовом случае лучше);

5) Далее вызывается функция vectorPartition, которая делит массив in-place согласно алгоритму в задании:
	а) Создаем индекс на левый left и крайний правый right (= конец вектора - 1) элементы;
	
	б) Находим середину массива для медианного опорного элемента, создаем случайный индекс между левым и крайним правым элементом, как остаток от деления случайного числа 
	на длину вектора = (правый индекс - левый индекс + 1);
	
	в) Для медианного опорного элемента используем функцию get_median и получаем медианного участника из трёх (попарно сравниваем числа: a < b, a < c, b < c и в случае положительного результата
	меняем содержимое элементов через swap => получим упорядоченный вектор c < b < a => медиана будет посередине => возвращает b, при этом функция реализована через итераторы => эти три элемента 
	будут сразу упорядочены в векторе => сокращает число операций по замене переменных местами);
	
	г) Для случайного опорного элемента берется элемент по адресу левый индекс + случайный индекс;
	
	д) Для опорного элемента из середины берется элемент по адрусу середины (right - left ) / 2;

	е) Далее мы сравниваем значение по левому индексу с опорным элементом и двигаем левый индекс вправо, до тех пор, пока значение больше опорного элемента. Сравниваем значение по правому индексу и 
	двигаем его влево, до тех пор, пока значение меньше опорного элемента. Тогда все элементы левее левого индекса будут больше опорного и все элементы правее правого индекс - меньше опорного;

	ж) Как только left <= опорного и right >= опорного, то у нас нарушется порядок элементов => поменяем эти элементы местами через swap;

	з) Повторяем пункты е)-ж) до тех пор, пока индексы не столкнуться: left != right, как только индексы встретятся, то у нас слева от left == right будут находиться элементы большие опорного, а
	справа от left == right будут находиться элементы меньшие опорного, тогда как по индексу left == right будет находиться сам опорный элемент, поскольку все участники будут линейно упорядочены =>
	будет возможен только один опорный элемент;

	и) Поскольку все операции происходят inplace, то есть элементы меняются через разименованные итераторы, то дополнительная память порядка O(n) не понадобится;
	
	к) Функция вернет индекс на опорный элемент;

6) Запишем возвращенный индекс от vectorPartition в переменную pivotal_point;

7) Далее вызывается рекурсивно быстрая сортировка на левой части массива => передаем полуинтервал [begin, pivotal_point), а затем на правой части [pivotal_point + 1, end). Гарантированно точки из
[begin, pivotal_point) будут больше pivotal_point и точки из [pivotal_point + 1, end) будут меньше, чем pivotal_point;

8) Массивы длины > 1 рекурсивно будут разделены на две части по новому опорному элементу. Массивы длины 1 сортировать не нужно, в силу чего функция сделает возврат и 
рекурсивно вернется к моменту вызова. Вектор участников будет отсортирован по принципу разделяй и властвуй. Глубина рекурсии в среднем будет равна O(log_2 n) (принимаем на веру, как факт), в худшем случае глубина будет равна n;

9) По завершению, функция выдаст отсортированный по убыванию вектор участников. Функцией printSortVector пройдемся по каждому участнику и выведем его имя;

ВРЕМЕННАЯ СЛОЖНОСТЬ:
1) Предположим, что у нас n участников, тогда на вход будет подаваться n записей, каждая из которых содержит до 20 символов текста и ровно 2 числа к ним => сложность записи на каждого из участников 
будет равна максимум 22 по линейности строки и двум числам => сложность записи n участников O(22n);

2) Алгоритм сортировки в среднем имеет сложность O(m log(m)), где m - число сравниваемых элементов. Тем не менее, поскольку мы сравниваем структуры, содержащие в себе строковый тип,
то лексикографическое сравнение может занять 2*min(N1,N2), где N1 - число символов в строке первого участника, N2 - число символов в строке второго участника => максимальное число операций за
сравнение = 2*20 + 2*2 = 44. При переупорядочивании массива происходит до 4 сравнений на каждый цикл, т.е. в худшем случае может произойти не больше, чем 4*44 сравнения (помечены ниже);

3) Таким образом, в среднем сложность такой сортировки будет порядка O(176n log(176n)) => при n = 100,000 сложность будет порядка ~ O(424,000,000), т.е. время выполнения будет максимум 0.5 секунд.
Остальные операции будут константного порядка;

4) В худшем случае алгоритм быстрой сортировки выполняется за O(m^2).
Итого: временная сложность в среднем ~O(m log(m)) = O(an log(an)), где a <= 176, в худшем случае сложность ~O((an)^2).

Обобщая: временная сложность в среднем ~O(n log(n)), в худшем случае ~O(n^2), худший случай возможен, например, если мы всегда выбираем 
опорным элементом крайний левый элемент, а сам массив у нас уже упорядочен. Тогда на каждом шаге мы будем разбивать массив на три части: пустая левая, опорный элемент и все элементы меньше опорного,
то есть n-k элементов, если мы находимся на k-ом шаге, итого число операций будет ~O((n - 1)* n/2) = O(n^2).

Для медианного опорного элемента также возможна своя киллер-последовательность, например, можно посмотреть тут: https://programmingpraxis.com/2016/11/08/a-median-of-three-killer-sequence/
Пример числовой последовательности из ссылки: 1 11 3 13 5 15 7 17 9 19 2 4 6 8 10 12 14 16 18 20

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
1) Каждая структура участника имеет сложность не больше 22 (20 на логин и 2 на штрафы и число решенных задач). Всего таких структур в векторе будет равно n => пространственная сложность
будет порядка O(22n), поскольку сортировка происходит по ссылкам, а сравнения локальные и не зависят от n, то пространственная сложность не будет расти больше этого размера;

2) Если строки максимум могут иметь длину 20 => размер строки будет как минимум 20 байт, + ещё 8 байт на два целых значения => при n = 100,000 мы получим не менее 2,800,000 байт занятой памяти =>
=> 2,800,000/(1024^2) =~ 2,67 МБ, т.е. в худшем случае будет занято около 3 МБ и ожидать результата меньше не имеет смысла, что бьется с результатами теста;

3) Итого: пространственная сложность имеет порядок ~ O(bn) в худшем случае, где b <= 24;

Обобщая: пространственная сложность ~O(n). Поскольку упорядочивание массива проводится по ссылкам, и значения изменяются через swap, то дополнительная память, зависящая от 
размера массива не требуется, используется константная память для локальных переменных, независимых от размера массива, т.е. функции vectorPartition, inplaceQuickSort, занимают память сложности ~O(1).

*/

#include<vector>
#include<iostream>
#include<string>
#include<utility>
using namespace std;

struct participant {
	string part_name;
	int nsolved;
	int penalty;
	participant() : part_name(""), nsolved(0), penalty(0) {}
	participant(string name_, int nsol, int penalt) : part_name(name_), nsolved(nsol), penalty(penalt) {}
};

using Iterator = vector<participant>::iterator;

bool operator<(const participant& lhs, const participant& rhs) {
	if (lhs.nsolved < rhs.nsolved) {
		return true;
	}
	else if (lhs.nsolved == rhs.nsolved) {
		if (lhs.penalty > rhs.penalty) {
			return true;
		}
		else if (lhs.penalty == rhs.penalty){
			if (lhs.part_name > rhs.part_name) {
				return true;
			}
		}
	}
	return false;
}


participant get_median(Iterator a, Iterator b, Iterator c) {
	if (*a < *b) swap(*a, *b);
	if (*a < *c) swap(*a, *c);
	if (*b < *c) swap(*b, *c);
	return *b;
}

Iterator vectorPartition(Iterator begin, Iterator end) {
	Iterator left = begin, right = end - 1;
	int med = (right - left) / 2;

	//Опорный элемент = медиана начала, середины и конца массива
	participant piv_value = get_median(left, left + med, right);

	//Опорный элемент = случайно выбранный индекс между 
	//int index = rand() % (right - left + 1);
	//participant piv_value = *(left + index);
	
	//Опорный элемент = середина массива
	//participant piv_value = *(left + med);

	while (left != right) {
		while(piv_value < *left) { //сравнение 1
			left++;
		}

		while(*right < piv_value) { //сравнение 2
			right--;
		}

		if(!(piv_value < *left) && !(*right < piv_value)) { //сравнение 3 и 4
			swap(*left, *right);
		}
	}
	return left;
}

void inplaceQuickSort(Iterator begin, Iterator end) {
	if (begin == end) { return; }

	Iterator pivotal_point = vectorPartition(begin, end);
	inplaceQuickSort(begin, pivotal_point);
	inplaceQuickSort(pivotal_point + 1, end);
}


void printSortVector(const vector<participant>& result) {
	int n = result.size();
	for (int i = 0; i < n; i++) {
		cout << result[i].part_name << endl;
	}
}

int main() {
	int n;
	cin >> n;
	vector<participant> results(n);
	
	string temp_string;
	int temp_sol, temp_penalty;
	for (int i = 0; i < n; i++) {
		cin >> temp_string >> temp_sol >> temp_penalty;
		participant temp_p(temp_string, temp_sol, temp_penalty);
		results[i] = move(temp_p);
	}
	inplaceQuickSort(results.begin(), results.end());
	printSortVector(results);
	return 0;
}